import os
import yaml
import shutil
from pathlib import Path
import random
import numpy as np
import torch
from ultralytics import YOLO


# Set random seed to ensure reproducibility
def set_seed(seed=42):
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False


set_seed()


def create_dataset_yaml(dataset_root, output_dir):

    # Create mapping from letters to class IDs
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    class_names = {i: letter for i, letter in enumerate(alphabet)}

    # Write dataset information
    dataset_info = {
        'path': dataset_root,
        'train': 'train/images',
        'val': 'valid/images',
        'test': 'test/images',
        'names': class_names,
        'nc': len(alphabet)
    }

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    yaml_path = os.path.join(output_dir, 'dataset.yaml')

    with open(yaml_path, 'w') as f:
        yaml.dump(dataset_info, f)

    return yaml_path


def fine_tune_yolo(dataset_yaml, epochs=100, batch_size=16, image_size=640, device="0", save_format="pth"):

    # Load pre-trained YOLOv8 model
    model = YOLO("yolov8n.pt")

    # Project and experiment name
    project_name = "hand_gesture_recognition"
    exp_name = "yolov8_fine_tuned"

    # Create log directory
    log_dir = os.path.join(project_name, exp_name, "logs")
    os.makedirs(log_dir, exist_ok=True)

    # Train model - use latest API format, only use supported parameters
    results = model.train(
        data=dataset_yaml,
        epochs=epochs,
        batch=batch_size,
        imgsz=image_size,
        device=device,
        patience=15,
        save=True,
        project=project_name,
        name=exp_name,
        pretrained=True,
        optimizer="SGD",
        cos_lr=True,
        lr0=0.01,
        lrf=0.01,
        momentum=0.937,
        weight_decay=0.0005,
        warmup_epochs=3,
        warmup_momentum=0.8,
        warmup_bias_lr=0.1,
        box=7.5,
        cls=0.5,
        dfl=1.5,
        hsv_h=0.015,
        hsv_s=0.7,
        hsv_v=0.4,
        degrees=15.0,
        translate=0.1,
        scale=0.5,
        shear=0.0,
        perspective=0.0,
        flipud=0.0,
        fliplr=0.5,
        mosaic=1.0,
        mixup=0.3,
        copy_paste=0.0,
        erasing=0.4,
        cache=True,
        exist_ok=True,
        workers=8,
        verbose=True,
    )

    # Validate model
    metrics = model.val()
    print(f"Validation results: {metrics}")

    # Read and parse training log file
    try:
        # Find the training log CSV file automatically generated by YOLOv8
        log_file = os.path.join(project_name, exp_name, "results.csv")
        if os.path.exists(log_file):
            import pandas as pd
            import matplotlib.pyplot as plt

            # Read the CSV log file
            metrics_df = pd.read_csv(log_file)

            # Create plots directory
            plot_dir = os.path.join(project_name, exp_name, "plots")
            os.makedirs(plot_dir, exist_ok=True)

            # Plot training loss curves
            plt.figure(figsize=(10, 6))
            if 'train/box_loss' in metrics_df.columns:
                plt.plot(metrics_df['epoch'], metrics_df['train/box_loss'], label='Box Loss')
            if 'train/cls_loss' in metrics_df.columns:
                plt.plot(metrics_df['epoch'], metrics_df['train/cls_loss'], label='Cls Loss')
            if 'train/dfl_loss' in metrics_df.columns:
                plt.plot(metrics_df['epoch'], metrics_df['train/dfl_loss'], label='DFL Loss')
            plt.xlabel('Epoch')
            plt.ylabel('Loss')
            plt.title('Training Loss')
            plt.legend()
            plt.grid(True)
            plt.savefig(os.path.join(plot_dir, 'training_loss.png'))
            plt.close()

            # Plot mAP curves
            plt.figure(figsize=(10, 6))
            if 'metrics/mAP50(B)' in metrics_df.columns:
                plt.plot(metrics_df['epoch'], metrics_df['metrics/mAP50(B)'], label='mAP50')
            if 'metrics/mAP50-95(B)' in metrics_df.columns:
                plt.plot(metrics_df['epoch'], metrics_df['metrics/mAP50-95(B)'], label='mAP50-95')
            plt.xlabel('Epoch')
            plt.ylabel('mAP')
            plt.title('Validation mAP')
            plt.legend()
            plt.grid(True)
            plt.savefig(os.path.join(plot_dir, 'validation_map.png'))
            plt.close()

            # Plot precision and recall curves
            plt.figure(figsize=(10, 6))
            if 'metrics/precision(B)' in metrics_df.columns:
                plt.plot(metrics_df['epoch'], metrics_df['metrics/precision(B)'], label='Precision')
            if 'metrics/recall(B)' in metrics_df.columns:
                plt.plot(metrics_df['epoch'], metrics_df['metrics/recall(B)'], label='Recall')
            plt.xlabel('Epoch')
            plt.ylabel('Value')
            plt.title('Precision and Recall')
            plt.legend()
            plt.grid(True)
            plt.savefig(os.path.join(plot_dir, 'precision_recall.png'))
            plt.close()

            print(f"Training metric plots have been saved to the {plot_dir} directory")

            # Print per-epoch accuracy
            print("\nPer-epoch Training and Validation Accuracy:")
            for i, row in metrics_df.iterrows():
                epoch = int(row['epoch'])
                train_loss = row.get('train/box_loss', 0) + row.get('train/cls_loss', 0) + row.get('train/dfl_loss', 0)
                val_map50 = row.get('metrics/mAP50(B)', 0)
                val_map = row.get('metrics/mAP50-95(B)', 0)
                print(
                    f"Epoch {epoch}: Training Loss: {train_loss:.4f}, Validation mAP50: {val_map50:.4f}, Validation mAP50-95: {val_map:.4f}")

            # Save accuracy summary to text file
            with open(os.path.join(log_dir, 'accuracy_summary.txt'), 'w') as f:
                f.write("Epoch,Training Loss,Validation mAP50,Validation mAP50-95\n")
                for i, row in metrics_df.iterrows():
                    epoch = int(row['epoch'])
                    train_loss = row.get('train/box_loss', 0) + row.get('train/cls_loss', 0) + row.get('train/dfl_loss',
                                                                                                       0)
                    val_map50 = row.get('metrics/mAP50(B)', 0)
                    val_map = row.get('metrics/mAP50-95(B)', 0)
                    f.write(f"{epoch},{train_loss:.4f},{val_map50:.4f},{val_map:.4f}\n")

            print(f"Accuracy summary has been saved to {os.path.join(log_dir, 'accuracy_summary.txt')}")

        else:
            print(f"Training log file not found: {log_file}")
    except Exception as e:
        print(f"Error processing training logs: {e}")

    # If need to save as .pth format, rename files
    if save_format.lower() == "pth":
        weights_dir = os.path.join(project_name, exp_name, "weights")

        # Rename best model
        if os.path.exists(os.path.join(weights_dir, "best.pt")):
            best_pt_path = os.path.join(weights_dir, "best.pt")
            best_pth_path = os.path.join(weights_dir, "best.pth")

            # Direct rename
            os.rename(best_pt_path, best_pth_path)

        # Rename last checkpoint
        if os.path.exists(os.path.join(weights_dir, "last.pt")):
            last_pt_path = os.path.join(weights_dir, "last.pt")
            last_pth_path = os.path.join(weights_dir, "last.pth")

            # Direct rename
            os.rename(last_pt_path, last_pth_path)

    return model, results


def prepare_background_images(dataset_root):
    # Create background images directory
    bg_dir = os.path.join(dataset_root, "backgrounds")
    os.makedirs(bg_dir, exist_ok=True)

    print(f"Please place diverse background images in the {bg_dir} directory for random background replacement")
    print("These images should not contain any hand gestures, and preferably be various environments, textures, or scenes")

    # Check if background images already exist
    bg_images = list(Path(bg_dir).glob("*.jpg")) + list(Path(bg_dir).glob("*.png"))
    if len(bg_images) == 0:
        print("Warning: No background images found. Random background replacement will not be effective.")
    else:
        print(f"Found {len(bg_images)} background images for random background replacement.")

    return bg_dir


def test_model(model, test_images_dir, conf_threshold=0.25):
    results = model.predict(
        source=test_images_dir,
        save=True,
        conf=conf_threshold,
        iou=0.45,
        max_det=300,
        line_width=2,
        save_txt=True,
        save_conf=True,
        save_crop=True,
        verbose=True,
    )

    # Calculate and print evaluation metrics
    metrics = model.val()
    print(f"Test set evaluation metrics:")
    print(f"mAP@0.5: {metrics.box.map50}")
    print(f"mAP@0.5:0.95: {metrics.box.map}")

    return results


def main():
    # Dataset path
    dataset_root = r"C:\Users\tians\OneDrive\Desktop\yolov8"
    output_dir = r"C:\Users\tians\OneDrive\Desktop\yolov8"

    # Prepare background images for random background replacement
    bg_dir = prepare_background_images(dataset_root)

    # Create dataset YAML
    dataset_yaml = create_dataset_yaml(dataset_root, output_dir)
    print(f"Dataset configuration has been saved to: {dataset_yaml}")

    # Fine-tune model
    model, results = fine_tune_yolo(
        dataset_yaml,
        epochs=100,
        batch_size=4,
        image_size=640,
        device="0",
        save_format="pth"
    )

    # Test model
    test_images_dir = os.path.join(dataset_root, "test", "images")
    test_results = test_model(model, test_images_dir, conf_threshold=0.25)

    print(f"Fine-tuning completed! Model has been saved in the hand_gesture_recognition_v2/yolov8_fine_tuned/directory")
    print(f"Training results: {results}")
    print(f"Test results: {test_results}")


if __name__ == "__main__":
    main()